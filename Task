Задача:
  0. Введение:
       FPGA выступает в роли приемника Ethernet пакетов. По потокам данных
       необходимо собирать статистику ( количество принятых байт ).
       В прошивке уже реализована логика определения типа потока ( его номера ). 

  1. Необходимо:
        Разработать модуль на языке Verilog/SystemVerilog, который
        позволит накапливать статистику по потокам. Предусмотреть
        возможность чтения этой статистики.

     Интерфейс модуля выглядит следующим образом:
     module pkt_stat
     #
     (
       // ширина адреса, минимальное число 10 -> 1024 адресов
       parameter A_WIDTH = 10,

       // ширина одного счетчика
       parameter D_WIDTH = 32
     )
     (

       // тактовый сигнал
       input                clk_i,

       // адрес для записи - номер/тип потока
       input [A_WIDTH-1:0]  rx_flow_num_i,

       // размер принятого пакета
       input [15:0]         pkt_size_i,

       // подтверждает валидность размера пакета
       // и rx_flow_num_i
       input                pkt_size_en_i,


       // ***** интерфейс чтения *****

       // строб чтения ( 0->1->0 ),
       // в этот момент rd_flow_num_i валиден
       input                rd_stb_i,

       // адрес по которому читать
       input [A_WIDTH-1:0]  rd_flow_num_i,
// прочитанные данные
       output [D_WIDTH-1:0] rd_data_o,

       // подтверждает, что rd_data_o валидны
       output               rd_data_val_o

     );

     // insert your code here

     endmodule

  2. Написать к этому простой тестбенч на языке SystemVerilog,
     который позволит проверить корректность работы этого модуля.


Примечания и советы:
  1. Этот модуль служит для промежуточного накопления статистики.
     Ее полноценное накопление и обработка происходит в другом месте
     ( MCU/CPU ), для этого и предусмотрен интерфейс чтения.

     Алгоритм чтения:
       1. Записывается значение адреса счетчика в rd_flow_num_i.
       2. Дергается строб rd_stb_i.
          При этом rd_data_val_o должен упасть в 0.
       3. Через какое-то количество тактов данные счетчика появляется
          на rd_data_o, и rd_data_val_o становится в 1.
       4. Значение счетчика внутри модуля при чтении обнуляется.

     Гарантируется, что процесс чтения не будет повторен, если еще
     модуль не отдал данные с предыдущего чтения.

     Количество тактов от rd_stb_i до rd_data_val_o не лимитировано,

    но чем меньше, тем лучше.

     При чтении допускается отдать не самые актуальные данные по счетчику.
     Но это должно быть компенсировано при следующем чтении этого счетчика.

  2. Все сигналы работают по clk_i.

  3. Пакеты ( их размер ) могут приходить каждый такт.

  4. Итоговая частота clk_i при синтезе этого модуля для чипа EP2AGX125C6 (
     или аналогичного из семества Arria II и C6 ) должна быть не менее 160 МГц.

